# 守护进程

## 编写思路

守护进程的书写涉及进程间通信的问题，进程间通信可以使用诸如信号，管道，共享内存，由于我们是为了监视服务程序是否运行正常，所以采用共享内存会简单一些，守护进程是为了监视服务程序是否运行正常，所以我们创建一个结构体保存进程的基本信息，然后将进程信息写入共享内存，守护进程 每隔一段遍历共享内存通过比较时间是否超时来检查以下进程是否正常运行，运行超时的就干掉进程，并且从共享内存中删除信息

具体编写流程

1. 创建、获取共享内存
2. 将共享内存连接到当前进程的地址空间
3. 遍历共享内存的全部记录
   1. 向进程发送信号0 判断是否存在，如果不存在就从共享内存中删除记录
   2. 发送信号15尝试终止进程，每隔一秒判断进程是否存在累计5秒
   3. 如果进程 依然存在，就发送信号9强行终止进程
   4. 删除已超时进程的心跳记录
4. 把共享内存从当前进程中分离

这里的难点就是共享内存的使用

## 共享内存的使用

1. 首先是创建和获取共享内存

   ```c++
   #define SHMKEYP   0x5095    // 共享内存的key。
   #define MAXNUMP     1000    // 最大的进程数量。
   // 进程心跳信息的结构体。
   struct st_procinfo
   {
     int    pid;         // 进程id。
     char   pname[51];   // 进程名称，可以为空。
     int    timeout;     // 超时时间，单位：秒。
     time_t atime;       // 最后一次心跳的时间，用整数表示。
   };
   shmget((key_t)SHMKEYP,MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)
   ```

   首先第一个参数指定共享内存的地址（16进制），第二个参数是指定共享内存的大小以及共享内存中的数据类型，这

   里给出的是程序定义的结构体用于保存进程的心跳，第三个参数就是指定共享内存的权限（以8进制）这里是给读和

   写的权限最后IPC_CREAT表示如果共享内存不存在就创建它。这样我们就创建了一个大小为1000的存有进程心跳结

   构体的共享内存

2. 将共享内存连接到当前进程地址

   ```c++
   struct st_procinfo* shm = (struct st_procinfo*)shmat(shmid, 0, 0);
   ```

   将shmid标识的共享内存段连接至当前进程地址空间，第一个参数是上面shmget函数的返回值，代表共享内存的表示

   第二个参数填0表示，如果shmaddr为NULL，系统将选择一个合适的（未使用的）地址来附加段。第三个参数用不上

   忽略。

3. 共享内存从当前进程中分离,就是类似free，没啥好说的

   ```c++
   shmdt(shm)
   ```

共享内存在项目中掌握着三个就足够了

**最后要注意的是kill() 函数发送0表示看看进程是否存在**，这一点需要注意！





